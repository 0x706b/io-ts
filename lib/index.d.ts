import { Either } from 'fp-ts/lib/Either';
import { Option } from 'fp-ts/lib/Option';
import { Predicate } from 'fp-ts/lib/function';
export interface ContextEntry {
    readonly key: string;
    readonly type: Any;
}
export declare type Context = Array<ContextEntry>;
export interface ValidationError {
    readonly value: any;
    readonly context: Context;
}
export declare type Validation<T> = Either<Array<ValidationError>, T>;
export declare type Validate<T> = (value: any, context: Context) => Validation<T>;
export declare type Any = Type<any>;
export declare type TypeOf<RT extends Any> = RT['t'];
export declare class Type<A> {
    readonly name: string;
    readonly validate: Validate<A>;
    readonly t: A;
    constructor(name: string, validate: Validate<A>);
    is(x: any): x is A;
}
export declare function getFunctionName(f: any): string;
export declare function failure<T>(value: any, context: Context): Validation<T>;
export declare function success<T>(value: T): Validation<T>;
export declare function validate<T>(value: any, type: Type<T>): Validation<T>;
declare module 'fp-ts/lib/HKT' {
    interface HKT<A> {
        'io-ts/Type': Type<A>;
    }
}
export declare const URI = "io-ts/Type";
export declare type URI = typeof URI;
export declare class MapType<RT extends Any, B> extends Type<B> {
    readonly type: RT;
    readonly f: (a: TypeOf<RT>) => B;
    constructor(name: string, type: RT, f: (a: TypeOf<RT>) => B);
}
export declare function map<RT extends Any, B>(f: (a: TypeOf<RT>) => B, type: RT): MapType<RT, B>;
export declare function mapWithName<RT extends Any, B>(f: (a: TypeOf<RT>) => B, type: RT, name: string): MapType<RT, B>;
/** A Getter can be seen as a glorified get method between a type S and a type A */
export declare type Getter<S, A> = (s: S) => Option<A>;
export declare class GetterType<RT extends Any, B> extends Type<B> {
    readonly type: RT;
    readonly getter: Getter<TypeOf<RT>, B>;
    constructor(name: string, type: RT, getter: Getter<TypeOf<RT>, B>);
}
export declare function getter<RT extends Any, B>(type: RT, getter: Getter<TypeOf<RT>, B>, name?: string): GetterType<RT, B>;
declare const nullType: Type<null>;
declare const undefinedType: Type<undefined>;
export declare const any: Type<any>;
export declare const never: Type<never>;
export declare const string: Type<string>;
export declare const number: Type<number>;
export declare const boolean: Type<boolean>;
declare const arrayType: Type<Array<any>>;
export declare const Dictionary: Type<{
    [key: string]: any;
}>;
declare const functionType: Type<Function>;
export declare class RefinementType<RT extends Any> extends Type<TypeOf<RT>> {
    readonly type: RT;
    readonly predicate: Predicate<TypeOf<RT>>;
    constructor(name: string, validate: Validate<TypeOf<RT>>, type: RT, predicate: Predicate<TypeOf<RT>>);
}
export declare function refinement<RT extends Any>(type: RT, predicate: Predicate<TypeOf<RT>>, name?: string): RefinementType<RT>;
export declare const Integer: RefinementType<Type<number>>;
export declare class LiteralType<T> extends Type<T> {
    readonly value: T;
    constructor(name: string, validate: Validate<T>, value: T);
}
export declare function literal<T extends string | number | boolean>(value: T): LiteralType<T>;
export declare class KeyofType<D extends {
    [key: string]: any;
}> extends Type<keyof D> {
    readonly keys: D;
    constructor(name: string, validate: Validate<keyof D>, keys: D);
}
export declare function keyof<D extends {
    [key: string]: any;
}>(map: D, name?: string): KeyofType<D>;
export declare function recursion<T>(name: string, definition: (self: Any) => Any): Type<T>;
export declare class ArrayType<RT extends Any> extends Type<Array<TypeOf<RT>>> {
    readonly type: RT;
    constructor(name: string, validate: Validate<Array<TypeOf<RT>>>, type: RT);
}
export declare function array<RT extends Any>(type: RT, name?: string): ArrayType<RT>;
export declare type Props = {
    [key: string]: Any;
};
export declare type InterfaceOf<P extends Props> = {
    [K in keyof P]: TypeOf<P[K]>;
};
export declare class InterfaceType<P extends Props> extends Type<InterfaceOf<P>> {
    readonly props: P;
    constructor(name: string, validate: Validate<InterfaceOf<P>>, props: P);
}
declare function interfaceType<P extends Props>(props: P, name?: string): InterfaceType<P>;
export declare type PartialOf<P extends Props> = {
    [K in keyof P]?: TypeOf<P[K]>;
};
export declare type PartialPropsOf<P extends Props> = {
    [K in keyof P]: UnionType<[P[K], Type<undefined>], [TypeOf<P[K]>, undefined]>;
};
export declare class PartialType<P extends Props> extends Type<PartialOf<P>> {
    readonly props: PartialPropsOf<P>;
    constructor(name: string, validate: Validate<PartialOf<P>>, props: PartialPropsOf<P>);
}
export declare function partial<P extends Props>(props: P, name?: string): PartialType<P>;
export declare class DictionaryType<D extends Type<string>, C extends Any> extends Type<{
    [key: string]: TypeOf<C>;
}> {
    readonly domain: D;
    readonly codomain: C;
    constructor(name: string, validate: Validate<{
        [key: string]: TypeOf<C>;
    }>, domain: D, codomain: C);
}
export declare function dictionary<D extends Type<string>, C extends Any>(domain: D, codomain: C, name?: string): DictionaryType<D, C>;
export declare type Match<RT extends Any, R> = (a: TypeOf<RT>) => R;
export declare class UnionType<RTS extends Array<Any>, U> extends Type<U> {
    readonly types: RTS;
    constructor(name: string, validate: Validate<U>, types: RTS);
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>, r: Match<RTS[17], R>, s: Match<RTS[18], R>, t: Match<RTS[19], R>, u: Match<RTS[20], R>, v: Match<RTS[21], R>, w: Match<RTS[22], R>, x: Match<RTS[23], R>, y: Match<RTS[24], R>, z: Match<RTS[25], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>, r: Match<RTS[17], R>, s: Match<RTS[18], R>, t: Match<RTS[19], R>, u: Match<RTS[20], R>, v: Match<RTS[21], R>, w: Match<RTS[22], R>, x: Match<RTS[23], R>, y: Match<RTS[24], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>, r: Match<RTS[17], R>, s: Match<RTS[18], R>, t: Match<RTS[19], R>, u: Match<RTS[20], R>, v: Match<RTS[21], R>, w: Match<RTS[22], R>, x: Match<RTS[23], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>, r: Match<RTS[17], R>, s: Match<RTS[18], R>, t: Match<RTS[19], R>, u: Match<RTS[20], R>, v: Match<RTS[21], R>, w: Match<RTS[22], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>, r: Match<RTS[17], R>, s: Match<RTS[18], R>, t: Match<RTS[19], R>, u: Match<RTS[20], R>, v: Match<RTS[21], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>, r: Match<RTS[17], R>, s: Match<RTS[18], R>, t: Match<RTS[19], R>, u: Match<RTS[20], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>, r: Match<RTS[17], R>, s: Match<RTS[18], R>, t: Match<RTS[19], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>, r: Match<RTS[17], R>, s: Match<RTS[18], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>, r: Match<RTS[17], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>, q: Match<RTS[16], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>, p: Match<RTS[15], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>, o: Match<RTS[14], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>, n: Match<RTS[13], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>, m: Match<RTS[12], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>, l: Match<RTS[11], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>, k: Match<RTS[10], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>, j: Match<RTS[9], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>, i: Match<RTS[8], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>, h: Match<RTS[7], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>, g: Match<RTS[6], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>, f: Match<RTS[5], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>, e: Match<RTS[4], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>, d: Match<RTS[3], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>, c: Match<RTS[2], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>, b: Match<RTS[1], R>): (value: U) => R;
    fold<R>(a: Match<RTS[0], R>): (value: U) => R;
}
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any, X extends Any, Y extends Any, Z extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q> | TypeOf<R> | TypeOf<S> | TypeOf<T> | TypeOf<U> | TypeOf<V> | TypeOf<W> | TypeOf<X> | TypeOf<Y> | TypeOf<Z>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any, X extends Any, Y extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q> | TypeOf<R> | TypeOf<S> | TypeOf<T> | TypeOf<U> | TypeOf<V> | TypeOf<W> | TypeOf<X> | TypeOf<Y>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any, X extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q> | TypeOf<R> | TypeOf<S> | TypeOf<T> | TypeOf<U> | TypeOf<V> | TypeOf<W> | TypeOf<X>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q> | TypeOf<R> | TypeOf<S> | TypeOf<T> | TypeOf<U> | TypeOf<V> | TypeOf<W>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q> | TypeOf<R> | TypeOf<S> | TypeOf<T> | TypeOf<U> | TypeOf<V>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q> | TypeOf<R> | TypeOf<S> | TypeOf<T> | TypeOf<U>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q> | TypeOf<R> | TypeOf<S> | TypeOf<T>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q> | TypeOf<R> | TypeOf<S>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q> | TypeOf<R>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P> | TypeOf<Q>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O> | TypeOf<P>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N> | TypeOf<O>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M> | TypeOf<N>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L, M], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L> | TypeOf<M>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K, L], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K> | TypeOf<L>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J, K], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J> | TypeOf<K>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any>(types: [A, B, C, D, E, F, G, H, I, J], name?: string): UnionType<[A, B, C, D, E, F, G, H, I, J], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I> | TypeOf<J>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any>(types: [A, B, C, D, E, F, G, H, I], name?: string): UnionType<[A, B, C, D, E, F, G, H, I], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H> | TypeOf<I>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any>(types: [A, B, C, D, E, F, G, H], name?: string): UnionType<[A, B, C, D, E, F, G, H], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G> | TypeOf<H>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any>(types: [A, B, C, D, E, F, G], name?: string): UnionType<[A, B, C, D, E, F, G], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F> | TypeOf<G>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any>(types: [A, B, C, D, E, F], name?: string): UnionType<[A, B, C, D, E, F], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E> | TypeOf<F>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any>(types: [A, B, C, D, E], name?: string): UnionType<[A, B, C, D, E], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D> | TypeOf<E>>;
export declare function union<A extends Any, B extends Any, C extends Any, D extends Any>(types: [A, B, C, D], name?: string): UnionType<[A, B, C, D], TypeOf<A> | TypeOf<B> | TypeOf<C> | TypeOf<D>>;
export declare function union<A extends Any, B extends Any, C extends Any>(types: [A, B, C], name?: string): UnionType<[A, B, C], TypeOf<A> | TypeOf<B> | TypeOf<C>>;
export declare function union<A extends Any, B extends Any>(types: [A, B], name?: string): UnionType<[A, B], TypeOf<A> | TypeOf<B>>;
export declare function union<A extends Any>(types: [A], name?: string): UnionType<[A], TypeOf<A>>;
export declare class IntersectionType<RTS, I> extends Type<I> {
    readonly types: RTS;
    constructor(name: string, validate: Validate<I>, types: RTS);
}
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any, X extends Any, Y extends Any, Z extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q> & TypeOf<R> & TypeOf<S> & TypeOf<T> & TypeOf<U> & TypeOf<V> & TypeOf<W> & TypeOf<X> & TypeOf<Y> & TypeOf<Z>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any, X extends Any, Y extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q> & TypeOf<R> & TypeOf<S> & TypeOf<T> & TypeOf<U> & TypeOf<V> & TypeOf<W> & TypeOf<X> & TypeOf<Y>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any, X extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q> & TypeOf<R> & TypeOf<S> & TypeOf<T> & TypeOf<U> & TypeOf<V> & TypeOf<W> & TypeOf<X>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q> & TypeOf<R> & TypeOf<S> & TypeOf<T> & TypeOf<U> & TypeOf<V> & TypeOf<W>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q> & TypeOf<R> & TypeOf<S> & TypeOf<T> & TypeOf<U> & TypeOf<V>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q> & TypeOf<R> & TypeOf<S> & TypeOf<T> & TypeOf<U>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q> & TypeOf<R> & TypeOf<S> & TypeOf<T>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q> & TypeOf<R> & TypeOf<S>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q> & TypeOf<R>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P> & TypeOf<Q>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O> & TypeOf<P>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N> & TypeOf<O>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M> & TypeOf<N>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L, M], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L> & TypeOf<M>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K, L], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K> & TypeOf<L>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J, K], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J> & TypeOf<K>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any>(types: [A, B, C, D, E, F, G, H, I, J], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I, J], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I> & TypeOf<J>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any>(types: [A, B, C, D, E, F, G, H, I], name?: string): IntersectionType<[A, B, C, D, E, F, G, H, I], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H> & TypeOf<I>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any>(types: [A, B, C, D, E, F, G, H], name?: string): IntersectionType<[A, B, C, D, E, F, G, H], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G> & TypeOf<H>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any>(types: [A, B, C, D, E, F, G], name?: string): IntersectionType<[A, B, C, D, E, F, G], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F> & TypeOf<G>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any>(types: [A, B, C, D, E, F], name?: string): IntersectionType<[A, B, C, D, E, F], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E> & TypeOf<F>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any>(types: [A, B, C, D, E], name?: string): IntersectionType<[A, B, C, D, E], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any>(types: [A, B, C, D], name?: string): IntersectionType<[A, B, C, D], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D>>;
export declare function intersection<A extends Any, B extends Any, C extends Any>(types: [A, B, C], name?: string): IntersectionType<[A, B, C], TypeOf<A> & TypeOf<B> & TypeOf<C>>;
export declare function intersection<A extends Any, B extends Any>(types: [A, B], name?: string): IntersectionType<[A, B], TypeOf<A> & TypeOf<B>>;
export declare function intersection<A extends Any>(types: [A], name?: string): IntersectionType<[A], TypeOf<A>>;
export declare class TupleType<RTS, T> extends Type<T> {
    readonly types: RTS;
    constructor(name: string, validate: Validate<T>, types: RTS);
}
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any, X extends Any, Y extends Any, Z extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>, TypeOf<R>, TypeOf<S>, TypeOf<T>, TypeOf<U>, TypeOf<V>, TypeOf<W>, TypeOf<X>, TypeOf<Y>, TypeOf<Z>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any, X extends Any, Y extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>, TypeOf<R>, TypeOf<S>, TypeOf<T>, TypeOf<U>, TypeOf<V>, TypeOf<W>, TypeOf<X>, TypeOf<Y>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any, X extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>, TypeOf<R>, TypeOf<S>, TypeOf<T>, TypeOf<U>, TypeOf<V>, TypeOf<W>, TypeOf<X>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any, W extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>, TypeOf<R>, TypeOf<S>, TypeOf<T>, TypeOf<U>, TypeOf<V>, TypeOf<W>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any, V extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>, TypeOf<R>, TypeOf<S>, TypeOf<T>, TypeOf<U>, TypeOf<V>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any, U extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>, TypeOf<R>, TypeOf<S>, TypeOf<T>, TypeOf<U>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any, T extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>, TypeOf<R>, TypeOf<S>, TypeOf<T>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any, S extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>, TypeOf<R>, TypeOf<S>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any, R extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>, TypeOf<R>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any, Q extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>, TypeOf<Q>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any, P extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>, TypeOf<P>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any, O extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>, TypeOf<O>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any, N extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M, N], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M, N], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>, TypeOf<N>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any, M extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L, M], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L, M], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>, TypeOf<M>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any, L extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K, L], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K, L], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>, TypeOf<L>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any, K extends Any>(types: [A, B, C, D, E, F, G, H, I, J, K], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J, K], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>, TypeOf<K>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any, J extends Any>(types: [A, B, C, D, E, F, G, H, I, J], name?: string): TupleType<[A, B, C, D, E, F, G, H, I, J], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>, TypeOf<J>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any, I extends Any>(types: [A, B, C, D, E, F, G, H, I], name?: string): TupleType<[A, B, C, D, E, F, G, H, I], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>, TypeOf<I>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any, H extends Any>(types: [A, B, C, D, E, F, G, H], name?: string): TupleType<[A, B, C, D, E, F, G, H], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>, TypeOf<H>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any, G extends Any>(types: [A, B, C, D, E, F, G], name?: string): TupleType<[A, B, C, D, E, F, G], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>, TypeOf<G>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any, F extends Any>(types: [A, B, C, D, E, F], name?: string): TupleType<[A, B, C, D, E, F], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>, TypeOf<F>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any>(types: [A, B, C, D, E], name?: string): TupleType<[A, B, C, D, E], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any>(types: [A, B, C, D], name?: string): TupleType<[A, B, C, D], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any>(types: [A, B, C], name?: string): TupleType<[A, B, C], [TypeOf<A>, TypeOf<B>, TypeOf<C>]>;
export declare function tuple<A extends Any, B extends Any>(types: [A, B], name?: string): TupleType<[A, B], [TypeOf<A>, TypeOf<B>]>;
export declare function tuple<A extends Any>(types: [A], name?: string): TupleType<[A], [TypeOf<A>]>;
export declare class ReadonlyType<RT extends Any> extends Type<Readonly<TypeOf<RT>>> {
    readonly type: RT;
    constructor(name: string, validate: Validate<Readonly<TypeOf<RT>>>, type: RT);
}
export declare function readonly<RT extends Any>(type: RT, name?: string): ReadonlyType<RT>;
export declare class ReadonlyArrayType<RT extends Any> extends Type<ReadonlyArray<TypeOf<RT>>> {
    readonly type: RT;
    constructor(name: string, validate: Validate<ReadonlyArray<TypeOf<RT>>>, type: RT);
}
export declare function readonlyArray<RT extends Any>(type: RT, name?: string): ReadonlyArrayType<RT>;
export { nullType as null, undefinedType as undefined, arrayType as Array, functionType as Function, interfaceType as interface };
